예약 생성 후 처리를 위한 Kafka 기반 이벤트 아키텍처 설계
1. 문제 정의: 동기적 핵심 트랜잭션의 부하와 후처리 작업의 분리 필요성
   현재 시스템은 아키텍처적으로 두 단계의 강력한 트래픽 제어 장치를 이미 갖추고 있습니다.
1. 1차 방어선 (토큰 발급): 대기열 토큰 발급 단계에서 분산 락과 Lua 스크립트를 통해 최초의 대규모 트래픽을 효과적으로 제어합니다.
2. 2차 방어선 (좌석 선점): '예약하기' API 내부에서 특정 좌석(seatId)에 대한 분산 락을 사용하여, 동일 좌석에 대한 동시 요청을 제어합니다.
   이러한 제어 장치 덕분에 무질서한 트래픽이 직접적으로 DB에 도달하지는 않습니다. 하지만, 분산 락을 획득한 **'이후'**에 실행되는 핵심 로직이 새로운 병목 지점이 됩니다.
* 문제점:
   * 무거운 동기 트랜잭션: 락이 확보된 상태에서 "예약 생성 + 좌석 상태 변경 + 결제 정보 생성"이라는 핵심 비즈니스 로직 전체가 하나의 동기 DB 트랜잭션으로 실행됩니다. 이 작업이 완료될 때까지 API 요청 스레드는 계속 대기해야 합니다.
   * 부가 작업으로 인한 지연: 여기에 더해, 예약 성공 후 처리해야 할 부가적인 후처리 작업(예: Redis에 좌석 임시 점유 정보 등록)까지 동기적으로 실행될 경우, Redis와 같은 외부 시스템의 일시적인 지연이 전체 트랜잭션과 API 응답 시간을 느리게 만드는 직접적인 원인이 됩니다.
   * 시스템 안정성 저하: 외부 시스템(Redis)의 장애가 핵심 기능인 예약 DB 트랜잭션의 성공 여부에까지 영향을 미치게 되어, 시스템의 결합도가 높아지고 안정성이 저해됩니다.
     따라서, 핵심 DB 트랜잭션은 동기적으로 처리하여 데이터 정합성을 보장하되, 부가적인 후처리 작업은 비동기적으로 분리하여 API의 응답 속도를 높이고 시스템의 안정성을 확보할 필요가 있습니다.
2. 고려된 아키텍처 설계안 및 최종 결정
   이 문제를 해결하기 위해 여러 아키텍처를 고려했으며, 각 설계안의 장단점을 분석하여 최종적으로 옵션 3을 채택했습니다.
   옵션 1: 예약만 동기 처리, 나머지는 비동기
* 설계: API 서버가 Reservation 레코드만 DB에 생성하여 reservationId를 반환하고, Payment 생성 및 Seat 상태 변경은 Kafka를 통해 비동기 처리합니다.
* 장점: API 응답이 매우 빠르면서도 reservationId를 즉시 반환할 수 있습니다.
* 단점 (치명적): 데이터 정합성을 깨뜨릴 위험이 매우 큽니다. 만약 Reservation은 생성되었는데, Kafka 컨슈머가 Payment 생성이나 Seat 상태 변경에 실패하면, 시스템에는 좌석은 여전히 AVAILABLE인데 유령 예약만 존재하는 심각한 데이터 불일치 상태가 발생합니다. 이를 해결하기 위한 복잡한 보상 트랜잭션 구현이 필요합니다.
  옵션 2: 모든 작업을 완전 비동기 처리 (Fire-and-Forget)
* 설계: API 서버는 요청을 받자마자 Kafka에 이벤트만 발행하고 즉시 응답합니다. 모든 DB 작업은 컨슈머가 처리합니다.
* 장점: API 응답 속도가 이론상 가장 빠릅니다.
* 단점 (치명적): API가 reservationId를 즉시 반환할 수 없어 사용자는 다음 단계인 결제를 진행할 수 없습니다. 이는 실제 서비스에서는 사용하기 어려운 구조입니다.
  옵션 2.5: ID 선발행 후 모든 작업 비동기 처리 (새로운 제안)
* 설계: API 서버가 UUID.randomUUID()를 통해 예약 ID를 미리 생성하여 사용자에게 즉시 반환하고, 이 ID를 포함한 모든 예약 정보를 Kafka 이벤트로 발행합니다. 모든 DB 작업은 컨슈머가 비동기적으로 처리합니다.
* 장점: 옵션 2의 단점을 보완하여, 가장 빠른 응답 속도를 유지하면서도 사용자에게 추적 가능한 ID를 제공할 수 있습니다.
* 단점 (치명적): 일관성 격차(Consistency Gap) 문제를 야기합니다. 사용자는 reservationId를 받았지만, Kafka 컨슈머의 처리가 1초라도 지연되면 그 시간 동안 DB에는 해당 예약 정보가 존재하지 않습니다. 만약 사용자가 이 ID로 즉시 결제를 시도하면, 결제 서비스는 존재하지 않는 예약을 처리하려다 실패하게 되어 매우 나쁜 사용자 경험을 유발합니다. 이 문제를 해결하려면 결제 서비스에 복잡한 재시도 로직을 구현해야 하는 등, 문제의 복잡성을 다른 서비스로 전가하게 됩니다.
  옵션 3: 핵심 트랜잭션은 동기, 후처리는 비동기 (채택)
* 설계: "예약 생성 + 좌석 상태 변경 + 결제 정보 생성"이라는 핵심 비즈니스 로직 전체를 하나의 DB 트랜잭션으로 묶어 동기적으로 처리하고, reservationId를 포함한 결과를 즉시 반환합니다. 그 외의 부가적인 후처리 작업(예: Redis 좌석 점유 정보 등록)은 reservation.created 이벤트를 통해 Kafka로 넘겨 비동기 처리합니다.
* 장점:
   * 강력한 데이터 정합성: 핵심 데이터가 하나의 트랜잭션으로 처리되어 데이터 불일치 위험이 없습니다.
   * 훌륭한 사용자 경험: 사용자는 예약 결과를 즉시 응답받아 다음 단계로 원활하게 넘어갈 수 있습니다.
   * 안정성: 시간이 걸릴 수 있는 부가 작업은 비동기로 분리되어 API 안정성에 영향을 주지 않습니다.
* 단점: 다른 옵션에 비해 API 응답 시간이 약간 더 길지만, DB 트랜잭션은 수십 밀리초(ms) 내에 완료되므로 사용자가 체감하기 어려운 수준입니다.
  최종 결정
  안정적인 서비스에서 가장 중요한 것은 데이터의 정합성입니다. 옵션 3은 약간의 API 응답 시간을 투자하는 대신, 가장 중요한 데이터의 정합성을 완벽하게 보장하면서, Kafka를 통해 무거운 후처리 작업을 비동기로 분리하여 시스템 전체의 안정성과 확장성까지 확보한, 가장 균형 잡히고 실용적인 아키텍처이므로 이 설계를 최종 채택합니다.
3. Kafka 도입 이유
   위 목표를 달성하기 위해, Apache Kafka를 핵심 트랜잭션과 비동기 후처리를 분리하는 중간 매개체로 활용합니다.
* 비동기 이벤트 발행: 예약 서비스는 핵심 DB 트랜잭션을 성공적으로 마친 뒤, reservation.created 이벤트를 Kafka에 발행합니다. 이 발행 작업은 매우 빠르므로 API 응답 시간에 거의 영향을 주지 않습니다.
* 신뢰성 있는 후처리 보장: 일단 이벤트가 Kafka에 발행되면, 후처리를 담당하는 컨슈머에 일시적인 장애가 발생하더라도 이벤트가 유실되지 않습니다. 컨슈머가 복구된 후 중단된 지점부터 다시 작업을 이어갈 수 있어, **최종적으로 모든 후처리 작업이 실행되는 것을 보장(Eventual Consistency)**합니다.
* 유연한 확장성: 향후 "예약 생성 시 알림 발송"과 같은 새로운 후처리 기능이 필요하다면, reservation.created 토픽을 구독하는 새로운 컨슈머를 추가하기만 하면 됩니다. 기존 예약 서비스의 코드는 전혀 수정할 필요가 없습니다.
4. 비즈니스 시퀀스 다이어그램 (개선 후)
   핵심 예약 처리는 동기적으로 수행하여 즉시 결과를 반환하고, 부가적인 후처리 작업은 Kafka 이벤트를 통해 비동기적으로 처리하는 하이브리드(Hybrid) 방식을 따릅니다.
![img.png](img/reservation_created_sequence_diagram.png)

5. Kafka 구성
* 핵심 토픽 (Topic):
   * reservation.created: 핵심 DB 트랜잭션이 성공적으로 완료된 후, 후속 처리가 필요할 때 발행되는 이벤트
* 프로듀서 (Producer):
   * ReservationInteractor: CreateReservationManager를 통해 DB 트랜잭션이 성공적으로 커밋된 후, reservation.created 이벤트를 발행합니다.
* 컨슈머 그룹 (Consumer Group): 예약 생성 후 필요한 후처리 작업을 담당하는 컨슈머입니다.
  컨슈머 클래스	구독 토픽	컨슈머 그룹 ID (application.yml)	역할
  ReservationCreatedSeatLockConsumer	reservation.created	reservation-created-group	Redis 좌석 임시 점유
6. 기대 효과
* 사용자 경험과 테스트 편의성 동시 확보: 사용자와 개발자 모두 예약 요청 즉시 예약 ID를 포함한 전체 결과를 응답받을 수 있습니다.
* 시스템 안정성 증대: 시간이 걸리거나 실패 가능성이 있는 외부 연동(Redis 등) 작업을 비동기로 분리하여, API의 안정성과 성능을 보장합니다.
* 유연한 아키텍처: 새로운 후처리 요구사항이 발생했을 때, 기존 코드를 수정하지 않고 새로운 컨슈머를 추가하는 것만으로 기능을 쉽게 확장할 수 있습니다.
