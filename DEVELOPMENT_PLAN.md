# 콘서트 예매 프로그램 개발 계획

## 1. 프로젝트 현황 요약

현재 콘서트 예매 프로그램은 대규모 트래픽에 대응하기 위한 동시성 제어 전략(다층적 락킹)과 클린/헥사고날 아키텍처, MSA 지향 설계를 기반으로 DDD 개발이 진행되고 있습니다. 결제 실패 시 보상 트랜잭션 로직이 Kafka 이벤트를 통해 트리거되는 형태로 구현되어 있어, 분산 시스템 환경에서의 안정성을 확보하기 위한 기반이 마련되어 있습니다.

**주요 성과:**
*   대규모 트래픽 환경에서의 동시성 문제 해결을 위한 다층적 락킹 전략 적용
*   클린 아키텍처 및 헥사고날 아키텍처를 통한 높은 유지보수성 및 확장성 확보
*   MSA 지향 설계 및 DDD를 통한 비즈니스 도메인 명확화
*   Kafka를 활용한 이벤트 기반 통신 및 결제 실패 보상 로직 구현

**보완점:**
*   전체적인 분산 트랜잭션의 일관성을 보장하는 사가 패턴의 부재 (현재는 단일 도메인 내 보상 로직)
*   도메인별 리소스 분리 미흡 (현재는 단일 모놀리식 데이터베이스 사용 가능성)
*   이벤트 소싱을 통한 데이터 이력 관리 및 시스템 상태 복원 기능 부재
*   이벤트 기록 및 조회를 위한 NoSQL 데이터베이스 활용 미흡

## 2. 다음 개발 단계 목표

### 2.1 단기 목표 (3개월 이내)
*   **도메인별 리소스 분리:** 핵심 도메인(예: 콘서트, 예약, 결제, 사용자)을 독립적인 서비스로 분리하고, 각 서비스가 전용 데이터베이스를 가지도록 전환합니다. (MSA 전환의 첫 단계)
*   **이벤트 소싱 도입을 위한 기반 마련:** 도메인 이벤트 정의 및 이벤트 저장소(Event Store) 설계. Kafka를 활용한 이벤트 발행/구독 모델을 더욱 견고히 합니다.
*   **사가 패턴 설계:** 여러 도메인 서비스에 걸친 비즈니스 프로세스(예: 예약 -> 결제 -> 알림)의 분산 트랜잭션 일관성을 보장하기 위한 사가 패턴(오케스트레이션 또는 코레오그래피)을 설계합니다.

### 2.2 중장기 목표 (6개월 이상)
*   **사가 패턴 구현:** 설계된 사가 패턴을 기반으로 핵심 비즈니스 프로세스에 사가 오케스트레이터 또는 코레오그래피를 구현하고, 보상 트랜잭션 로직을 확장합니다.
*   **NoSQL 기반 이벤트 저장소 구축:** 이벤트 소싱을 위해 NoSQL 데이터베이스(예: MongoDB, Cassandra, DynamoDB 등)를 도입하여 이벤트 기록의 성능과 확장성을 확보합니다.
*   **CQRS 도입 (선택적):** 읽기 모델과 쓰기 모델을 분리하여 시스템의 성능 및 확장성을 최적화합니다.
*   **모니터링 및 로깅 강화:** 분산 시스템 환경에 최적화된 통합 모니터링 및 로깅 시스템을 구축합니다 (예: ELK Stack, Prometheus + Grafana).
*   **관리자 기능 개발:** 콘서트 관리, 사용자 관리, 예매 현황 모니터링 등 관리자용 백오피스 기능을 개발합니다.

## 3. 핵심 개발 과제 및 세부 계획

### 3.1 과제 1: 도메인별 리소스 분리 (MSA 전환)
*   **목표:** 각 핵심 도메인이 독립적인 서비스와 데이터베이스를 가지도록 분리하여 MSA 아키텍처를 강화합니다.
*   **세부 계획:**
    *   **도메인 식별 및 경계 설정:** 현재 모놀리식 코드베이스에서 콘서트, 예약, 결제, 사용자 등 핵심 도메인을 명확히 식별하고 서비스 경계를 정의합니다.
    *   **데이터베이스 분리:** 각 서비스가 전용 데이터베이스를 사용하도록 데이터 마이그레이션 전략을 수립하고 실행합니다.
    *   **서비스 간 통신 방식 정의:** REST API, gRPC, Kafka 이벤트 등 서비스 간 통신 방식을 정의하고 구현합니다.
    *   **API Gateway 도입 (선택적):** 서비스 라우팅, 인증/인가, 로드 밸런싱 등을 위한 API Gateway 도입을 고려합니다.
*   **기술적 고려사항:** 데이터 일관성 유지 방안 (분산 트랜잭션 문제), 서비스 디스커버리, 설정 관리.

### 3.2 과제 2: 이벤트 소싱 도입
*   **목표:** 모든 도메인 상태 변경을 이벤트로 기록하고, 이를 통해 시스템의 이력 관리 및 상태 복원 기능을 확보합니다.
*   **세부 계획:**
    *   **도메인 이벤트 정의:** 각 도메인에서 발생하는 중요한 비즈니스 이벤트를 식별하고 표준화된 이벤트 스키마를 정의합니다.
    *   **이벤트 발행:** 도메인 모델에서 상태 변경 시 이벤트를 발행하도록 구현합니다.
    *   **이벤트 저장소 설계:** 발행된 이벤트를 영구적으로 저장할 이벤트 저장소의 스키마를 설계합니다.
    *   **이벤트 컨슈머 구현:** 이벤트 저장소에 저장된 이벤트를 구독하여 필요한 작업을 수행하는 컨슈머를 구현합니다.
*   **기술적 고려사항:** 이벤트 스키마 버전 관리, 이벤트 저장소의 성능 및 확장성, 이벤트 재생(Replay) 전략.

### 3.3 과제 3: 사가 패턴 구현
*   **목표:** 여러 도메인 서비스에 걸친 비즈니스 프로세스의 분산 트랜잭션 일관성을 보장합니다.
*   **세부 계획:**
    *   **핵심 비즈니스 프로세스 식별:** 사가 패턴을 적용할 예약 -> 결제 -> 알림과 같은 다단계 비즈니스 프로세스를 식별합니다.
    *   **사가 오케스트레이터/코레오그래피 설계:** 중앙 집중식 오케스트레이터 또는 분산된 코레오그래피 방식 중 프로젝트에 적합한 사가 패턴을 설계합니다.
    *   **보상 트랜잭션 로직 확장:** 각 서비스에서 사가 실패 시 실행될 보상 트랜잭션 로직을 구현하고, 기존 결제 실패 보상 로직과 통합합니다.
    *   **사가 상태 관리:** 사가의 현재 상태를 추적하고 관리하는 메커니즘을 구현합니다.
*   **기술적 고려사항:** 사가 실패 시 재시도 및 데드 레터 큐(DLQ) 처리, 사가 모니터링, 멱등성(Idempotency) 보장.

### 3.4 과제 4: NoSQL 기반 이벤트 저장소 구축
*   **목표:** 이벤트 소싱을 위한 고성능, 고확장성 이벤트 저장소를 NoSQL 데이터베이스로 구축합니다.
*   **세부 계획:**
    *   **NoSQL 데이터베이스 선정:** 프로젝트 요구사항(성능, 확장성, 비용, 운영 용이성 등)에 맞는 NoSQL 데이터베이스(예: MongoDB, Cassandra, DynamoDB)를 선정합니다.
    *   **이벤트 저장소 구현:** 선정된 NoSQL 데이터베이스를 활용하여 이벤트 저장소를 구현하고, 이벤트 발행 및 조회를 위한 API를 개발합니다.
    *   **기존 Kafka 이벤트와의 연동:** Kafka를 통해 발행된 이벤트를 NoSQL 이벤트 저장소에 기록하는 방안을 마련합니다.
*   **기술적 고려사항:** NoSQL 데이터 모델링, 데이터 일관성 모델 (최종 일관성), 백업 및 복구 전략.

## 4. 예상 일정 (추정)

*   **1단계 (1-2개월):** 도메인별 리소스 분리 (MSA 전환), 이벤트 소싱 기반 설계
*   **2단계 (2-3개월):** 사가 패턴 설계 및 핵심 비즈니스 프로세스에 대한 사가 구현 시작
*   **3단계 (3-4개월):** NoSQL 기반 이벤트 저장소 구축 및 이벤트 소싱 구현 완료
*   **4단계 (4개월 이후):** 사가 패턴 확장, CQRS 도입 (선택적), 모니터링 및 로깅 시스템 고도화, 관리자 기능 개발

**참고:** 위 일정은 추정치이며, 실제 개발 진행 상황에 따라 유동적으로 변경될 수 있습니다.

## 5. 오픈 질문 및 미결 사항

*   각 도메인 서비스의 최종적인 경계 및 책임 정의에 대한 팀 내 합의 필요
*   사가 패턴 구현을 위한 구체적인 프레임워크 또는 라이브러리 선정 (예: Axon Framework, Spring Cloud Saga 등)
*   NoSQL 데이터베이스 선정에 대한 상세한 기술 검토 및 PoC (Proof of Concept) 진행
*   MSA 전환 시 기존 데이터 마이그레이션 전략 구체화
*   CI/CD 파이프라인의 MSA 환경에 대한 재구성 방안 마련